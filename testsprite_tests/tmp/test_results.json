[
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "a5dc0bd2-415e-4541-a302-b051fc022f3a",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC001-User Authentication with Valid Credentials",
    "description": "Verify that the system allows login with correct username and password, persists session, and redirects to dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Find the correct login page or a link/button to navigate to the login page from the current or home page.\n        await page.goto('http://localhost:5500', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input valid username and password, then submit the login form.\n        frame = context.pages[-1]\n        # Input valid username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Input valid password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit the form\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Failed: Invalid credentials').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan execution has failed because the system did not authenticate the user successfully, persist the session, or redirect to the dashboard as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The system does not allow login with the provided correct username and password as it shows an error message 'Username atau password salah'. Therefore, the login, session persistence, and dashboard redirection cannot be verified. Task stopped due to failed login.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/style/asset/image/larosa-logo.png:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/1767321767631571//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.176Z",
    "modified": "2026-01-02T02:42:47.752Z"
  },
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "cebc5f4a-30a7-4ed9-9eb8-f431cea876a5",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC002-User Authentication with Invalid Credentials",
    "description": "Verify login failure with incorrect username or password and appropriate error message display.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check for alternative navigation or URL to access the login page or report the issue.\n        await page.goto('http://localhost:5500', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Enter invalid username and password, then submit the login form.\n        frame = context.pages[-1]\n        # Enter invalid username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalidUser')\n        \n\n        frame = context.pages[-1]\n        # Enter invalid password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongPassword')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit the form\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Username atau password salah').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=LOGIN').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/176732177256645//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.185Z",
    "modified": "2026-01-02T02:42:52.694Z"
  },
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "7dc694c1-8105-49f3-898a-96cf97123411",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC003-Dashboard Data Accuracy and Real-Time Updates",
    "description": "Verify dashboard displays up-to-date business metrics, sales trends, and charts reflecting latest cached data.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to navigate to the home page or root URL to find a login link or dashboard access\n        await page.goto('http://localhost:5500/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input username and password, then click login button to access dashboard\n        frame = context.pages[-1]\n        # Input username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click login button\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dashboard metrics are fully outdated').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Dashboard does not display up-to-date business metrics, sales trends, and charts reflecting latest cached data as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login failed due to incorrect credentials. Unable to access dashboard to verify business metrics, sales trends, and charts. Please provide valid login credentials to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/style/asset/image/larosa-logo.png:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/1767321776253132//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.191Z",
    "modified": "2026-01-02T02:42:56.372Z"
  },
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "ae66a123-182b-449b-bc83-4a7b1d6582cb",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC004-POS Invoice Creation and Payment Handling",
    "description": "Verify creation of sales invoice with multiple products, selection of customer, handling of full and partial payments including down payments, and saving transaction persistently.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to navigate to the home page or root URL to find a working entry point for the application.\n        await page.goto('http://localhost:5500/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input username and password, then click login button to access the application.\n        frame = context.pages[-1]\n        # Input username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click login button\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check if there is a way to reset password or verify credentials, or try a different approach to access the application.\n        frame = context.pages[-1]\n        # Click login button again to see if any additional error or options appear\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Invoice Creation Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Sales invoice creation with multiple products, customer selection, full and partial payments, and transaction saving did not complete successfully as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login failed due to incorrect credentials. Cannot proceed with testing invoice creation and payment flows without successful login. Please provide valid credentials or alternative access method.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/style/asset/image/larosa-logo.png:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/1767321776882264//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.197Z",
    "modified": "2026-01-02T02:42:57.015Z"
  },
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "1e533b60-41d6-46c1-a02b-0ab7ba096601",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC005-Product Inventory CRUD and Stock Management",
    "description": "Verify adding, editing, deleting products with validation, and stock updates reflecting real-time changes including restock alerts.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check if there is a homepage or alternative entry point to access the product inventory module.\n        await page.goto('http://localhost:5500', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input username and password, then click login button to access the system.\n        frame = context.pages[-1]\n        # Input username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click login button\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Product Inventory Module Access Granted').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan execution failed to verify adding, editing, deleting products with validation, and stock updates including restock alerts.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login failed due to incorrect username or password. Cannot proceed with product inventory testing without valid login credentials. Please provide correct credentials or alternative user access.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/style/asset/image/larosa-logo.png:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/17673217707599//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.203Z",
    "modified": "2026-01-02T02:42:50.880Z"
  },
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "5846816c-b16c-4918-80bc-f10da0ab9539",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC006-Customer Management with Validation and CRUD",
    "description": "Verify adding, editing, deleting customers with validation for phone and duplicate checking and correctness of transaction linkage.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check if there is an alternative way to access the customer management module or fix the URL.\n        await page.goto('http://localhost:5500', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input username and password, then click login button to access the system.\n        frame = context.pages[-1]\n        # Input username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click login button\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Customer successfully added').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed during customer management operations including adding, editing, deleting customers with validation for phone and duplicate checking and correctness of transaction linkage.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login failed due to incorrect username or password. Cannot proceed with customer management testing without successful login. Please provide correct credentials or further instructions.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/style/asset/image/larosa-logo.png:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/1767321771688116//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.208Z",
    "modified": "2026-01-02T02:42:51.814Z"
  },
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "1a40c3f7-6afb-4703-8083-1401e122b0af",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC007-Vendor Management with Full CRUD Operations",
    "description": "Verify adding, editing, and deleting vendors with complete contact and banking info handled correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to navigate to the home page or root URL to find a working entry point for the application.\n        await page.goto('http://localhost:5500/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input username and password, then click login button to access the application.\n        frame = context.pages[-1]\n        # Input username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click login button\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Vendor successfully added with complete contact and banking info').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The vendor management module did not handle adding, editing, and deleting vendors with complete contact and banking info correctly as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login failed due to incorrect username or password. Cannot proceed with vendor management testing without successful login. Please provide correct credentials or alternative instructions.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/style/asset/image/larosa-logo.png:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/1767321769613523//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.215Z",
    "modified": "2026-01-02T02:42:49.739Z"
  },
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "d28d40e3-b277-4ae0-ad15-945a70e12ff1",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC008-Transaction History View, Edit, and Delete Functionality",
    "description": "Verify the transaction history module correctly groups invoices, allows viewing details, editing, and deleting existing transactions with backend sync.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check for alternative navigation options or home page to access the transaction history module.\n        await page.goto('http://localhost:5500', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input username and password, then click login button to access the application.\n        frame = context.pages[-1]\n        # Input the username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Input the password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click the login button\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Retry login with correct credentials or check for password reset or alternative login options.\n        frame = context.pages[-1]\n        # Re-input the username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Re-input the password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click the login button again\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Transaction History Module Loaded Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The transaction history module did not load or function as expected. This includes grouping invoices, viewing details, editing, and deleting transactions with backend synchronization.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify the transaction history module could not be completed because the login attempts with the provided credentials failed. The system displayed an error message 'Username atau password salah' indicating incorrect username or password. Without successful login, access to the transaction history module and subsequent verification of invoice grouping, viewing, editing, and deleting transactions with backend sync was not possible. Please provide correct login credentials to proceed with the task.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/style/asset/image/larosa-logo.png:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/1767321839865329//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.220Z",
    "modified": "2026-01-02T02:44:00.039Z"
  },
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "66b66a44-dbf1-4dbc-a9cb-006ed79bb7d0",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC009-Payment Settlement Processing for Down Payments",
    "description": "Verify tracking, partial and full payment processing of down payment invoices in Pelunasan module with status updates and data synchronization.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Investigate alternative navigation or URL to access the application main page or login page.\n        await page.goto('http://localhost:5500', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input username and password, then click login button to access the application.\n        frame = context.pages[-1]\n        # Input username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click login button\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Payment Settlement Completed Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The payment processing and settlement status updates in the Pelunasan module did not complete as expected. The expected confirmation \"Payment Settlement Completed Successfully\" was not found on the page.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login failed due to incorrect credentials. Unable to proceed with testing the Pelunasan module without valid login. Please provide correct username and password to continue.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/style/asset/image/larosa-logo.png:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/1767321769712203//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.230Z",
    "modified": "2026-01-02T02:42:49.835Z"
  },
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "a82bb821-597f-49df-8885-f2cf8ad76fa4",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC010-Quotation Creation, Management, and Invoice Conversion",
    "description": "Verify workflow to create new quotations, view and edit existing ones, and convert quotations into sales invoices maintaining data integrity.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check the homepage or root URL for navigation to login or quotation module\n        await page.goto('http://localhost:5500', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input username and password, then click login button\n        frame = context.pages[-1]\n        # Input username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click login button\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify credentials or try alternative login credentials or methods\n        frame = context.pages[-1]\n        # Clear username field\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Clear password field\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        # -> Request correct login credentials or instructions to proceed with login\n        frame = context.pages[-1]\n        # Re-input username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Re-input password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click login button again\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Quotation Conversion Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The workflow to create, view, edit quotations and convert them into sales invoices did not complete successfully as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login failed due to incorrect username or password. Unable to proceed with the workflow to create, view, edit, and convert quotations. Please provide correct login credentials to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/style/asset/image/larosa-logo.png:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/1767321824581106//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.240Z",
    "modified": "2026-01-02T02:43:44.717Z"
  },
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "75d2fcc9-8f6a-4916-81e9-f2730138a695",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC011-Invoice Generation and Printing for Full and Partial Payments",
    "description": "Verify invoices generated from transactions support printing with accurate details for full and partial payments including editable fields.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check the homepage or root URL for navigation options to login or other relevant pages.\n        await page.goto('http://localhost:5500/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input username and password, then click login button.\n        frame = context.pages[-1]\n        # Input the username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Input the password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click the login button\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Invoice Payment Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Invoice generation and printing verification did not pass as per the test plan. The expected confirmation text \"Invoice Payment Successful\" was not found, indicating issues with invoice details or print output.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login failed due to incorrect credentials. Cannot proceed with invoice generation and printing verification without successful login. Please provide correct username and password to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/style/asset/image/larosa-logo.png:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/1767321769243538//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.246Z",
    "modified": "2026-01-02T02:42:49.365Z"
  },
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "c509c685-9b59-4f3e-a92c-1100bdc8d7f3",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC012-IndexedDB Cache and Google Sheets Data Synchronization",
    "description": "Verify cache-first data service correctly synchronizes data between IndexedDB and Google Sheets backend ensuring consistency and offline functionality.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check for alternative navigation or URL to access the app login or main page.\n        await page.goto('http://localhost:5500', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input username and password, then click login button.\n        frame = context.pages[-1]\n        # Input the username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Input the password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click the login button\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Synchronization Complete').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Cache-first data service did not synchronize data correctly between IndexedDB and Google Sheets backend, causing inconsistency and offline functionality issues.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login failed due to incorrect username or password. Cannot proceed with offline CRUD and synchronization tests without successful login. Please provide correct credentials or alternative access method.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/style/asset/image/larosa-logo.png:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/1767321775481647//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.251Z",
    "modified": "2026-01-02T02:42:55.828Z"
  },
  {
    "projectId": "ed759a13-846c-4e09-8e39-be4aaa98da5f",
    "testId": "e996d288-8bb4-4f07-898c-b3cf6c2e7e60",
    "userId": "f4d82418-b051-703f-cec0-f088688bde5c",
    "title": "TC013-Responsive UI Components Across Supported Devices",
    "description": "Verify sidebar navigation, autocomplete inputs, loading indicators, and other UI components render and operate responsively on various screen sizes and devices.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5500/login\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to navigate to the home page or root URL to find a working entry point to the app.\n        await page.goto('http://localhost:5500/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input username and password, then click the login button to access the app.\n        frame = context.pages[-1]\n        # Input the username\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('daffarafdhan')\n        \n\n        frame = context.pages[-1]\n        # Input the password\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click the login button\n        elem = frame.locator('xpath=html/body/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Responsive Sidebar Navigation Test Passed').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Sidebar navigation, autocomplete inputs, loading indicators, and other UI components did not render or operate responsively on various screen sizes and devices as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login failed due to incorrect username or password. Unable to proceed with UI component testing on the app pages. Please verify or provide correct login credentials to continue testing sidebar navigation, autocomplete inputs, loading indicators, and other UI components on various screen sizes.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:5500/style/asset/image/larosa-logo.png:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f4d82418-b051-703f-cec0-f088688bde5c/176732177735305//tmp/test_task/result.webm",
    "created": "2026-01-02T02:41:27.257Z",
    "modified": "2026-01-02T02:42:57.474Z"
  }
]
